{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About Me","text":"<p>I'm Brian Bascom, an undergraduate student in Computer Engineering at Brigham Young University. Current research assistant at the BYU MAGICC Lab.</p> <p></p> <p> Resume</p>"},{"location":"#education","title":"Education","text":"<p>Bachelor of Science in Computer Engineering (2027) Minor in Computer Science and Mathematics  </p>"},{"location":"#honors-awards","title":"Honors &amp; Awards","text":"<ul> <li>Honors Program  </li> <li>Russell M. Nelson Presidential Scholar  </li> <li>National Merit Scholar</li> </ul>"},{"location":"#skills","title":"Skills","text":"<ul> <li>Programming Languages: Rust, C, C++, Python, Java</li> <li>Developer Tools: Git, VS Code, Linux, Docker, CMake</li> <li>Hardware &amp; Lab: Raspberry Pi, UAVs, STM32 Microcontrollers, KiCad</li> <li>Software: PyTorch, JAX, ONNX</li> </ul>"},{"location":"#interests","title":"Interests","text":"<ul> <li>Control Theory</li> <li>Machine Learning</li> <li>Embedded Systems</li> <li>Robotics</li> <li>Rust Programming Language</li> </ul>"},{"location":"#projects","title":"Projects","text":"<p>View my projects on my projects page of this website</p>"},{"location":"github/","title":"Github","text":"<p>Github. This page will be redirected.</p>"},{"location":"magicc/","title":"MAGICC Lab","text":"<p>I am currently working in the BYU Multiple Agent Intelligent Coordination and Control (MAGICC) Lab as a research assistant. I started in this position in April 2025 as a part of the IMMERSE Program under Dr. James Usevitch.</p> <p></p>"},{"location":"portfolio/projects_deprecated/","title":"Projects deprecated","text":"<p>These projects span my time as an undergraduate student. They cover major class assignments in the BYU Electrical &amp; Computer Engineering and Computer Science departments, tasks as a research assistant in the MAGICC lab, and personal projects I've completed in my spare time.</p> <ul> <li> All </li> <li> Software </li> <li> Hardware </li> <li> Robotics </li> </ul> <ul> <li> <p>Keyboard Project</p> <p>A custom split keyboard.</p> <p>Hardware Software</p> <p></p> </li> <li> <p>Raspberry Pi Doorbell</p> <p>ECEN 225</p> <p>Hardware Software</p> </li> <li> <p>Light Following Robot</p> <p>ECEN 240</p> <p>Robotics</p> </li> <li> <p>C Battleship</p> <p>ECEN 330</p> <p>Software</p> </li> <li> <p>RustFlight</p> <p>MAGICC Lab</p> <p>Hardware Software</p> </li> <li> <p>Rust Demos</p> <p>Rust Programming Language</p> <p>Software</p> </li> <li> <p>This website!</p> <p>Material for MKDocs</p> <p>Software</p> </li> </ul>"},{"location":"portfolio/projects_js/","title":"Projects js","text":"<p>These projects span my time as an undergraduate student...</p> All Software Hardware MAGICC LAB <ul> <li> <p>ROSflight</p> <p>MAGICC Lab</p> <p>Software Hardware MAGICC Lab</p> <p></p> </li> <li> <p>Rust Demos</p> <p>Rust Programming Language</p> <p>Software MAGICC Lab</p> <p></p> </li> <li> <p>Keyboard Project</p> <p>A custom split keyboard.</p> <p>Hardware</p> <p></p> </li> <li> <p>Raspberry Pi Doorbell</p> <p>ECEN 225 (Computer Systems) Lab</p> <p>Hardware Software</p> <p></p> </li> <li> <p>Light Following Robot</p> <p>ECEN 240 (Circuits) Lab</p> <p>Hardware Software</p> <p></p> </li> <li> <p>C Battleship</p> <p>ECEN 330 (Embedded Programming) Lab</p> <p>Software</p> <p></p> </li> <li> <p>Chess Project</p> <p>CS 240 (Adv. Software Construction)</p> <p>Software</p> <p></p> </li> <li> <p>This website!</p> <p>Material for MKDocs</p> <p>Software</p> <p></p> </li> </ul>"},{"location":"portfolio/projects_simplified/","title":"Projects","text":"<p>These projects span my time as an undergraduate student. They cover major class assignments in the BYU Electrical &amp; Computer Engineering and Computer Science departments, tasks as a research assistant in the MAGICC lab, and personal projects I've completed in my spare time.</p> <ul> <li> <p>Keyboard Project</p> <p>A custom split keyboard.</p> <p></p> </li> <li> <p>RustFlight</p> <p>MAGICC Lab</p> <p></p> </li> <li> <p>Raspberry Pi Doorbell</p> <p>ECEN 225 (Computer Systems) Lab</p> <p></p> </li> <li> <p>Rust Demos</p> <p>Rust Programming Language</p> <p></p> </li> <li> <p>Chess Project</p> <p>CS 240 (Adv. Software Construction)</p> <p></p> </li> <li> <p>C Battleship</p> <p>ECEN 330 (Embedded Programming) Lab</p> <p></p> </li> <li> <p>Light Following Robot</p> <p>ECEN 240 (Circuits) Lab</p> <p></p> </li> <li> <p>This website!</p> <p>Material for MkDocs</p> <p></p> </li> </ul>"},{"location":"portfolio/projects/c_battleship/","title":"C Battleship","text":"<p>ECEN 330 Embedded Programming class project in collaboration with Blake Sanders. We created a 2-player Battleship game playable on two game controllers connected via UART. Details coming soon.</p>"},{"location":"portfolio/projects/chess/","title":"Chess Project","text":"<p>Full-stack chess application built as a course project for BYU CS 240 (Advanced Software Construction). It features a networked client-server architecture, with a command-line client, a server to manage users and games, and shared modules for implementing chess rules and game state management.</p>"},{"location":"portfolio/projects/doorbell/","title":"Raspberry Pi Doorbell","text":"<p>In ECEN 224 (Intro to Computer Systems) I created a Raspberry Pi Doorbell system. This project included a Raspberry Pi Zero, LCD hat, and camera module in a 3D printed case. I loved building and programming the doorbell during this class. </p> <p>As a part of the IMMERSE program, I was given the assignment to create a demonstration of the doorbell to be used for new student orientation. I decided to redesign the cover to show off the device's hardware. I laser cut a transparent acrylic cover and 3D printed some parts to replace the original case. I assembled this demonstration and programmed it with a custom program that showcases a few of the doorbell's features with a focus on the camera functionality and basic digital image processing. The following is a part of the demonstration guide I wrote for new student orientation to accompany the device.</p>"},{"location":"portfolio/projects/doorbell/#doorbell-demo","title":"Doorbell Demo","text":"<p>Students in ECEN 224 (Intro to Computer Systems) learn to program a video doorbell in their lab!</p> <p></p> <p>This code is a simple demonstration of some of the features students will learn to program in the class.</p>"},{"location":"portfolio/projects/doorbell/#camera-control","title":"Camera Control","text":"<p>Press the Center button to take a picture with the camera! The result will be displayed on the screen. Press the Center button again to clear the display. </p>"},{"location":"portfolio/projects/doorbell/#color-filters","title":"Color Filters","text":"<p>While a picture is showing, move the joystick to add a color filter:</p> <ul> <li>Right \u2013 Filter out RED color</li> <li>Up \u2013 Filter out GREEN color</li> <li>Left \u2013 Filter out BLUE color</li> <li>Down \u2013 Filter out ALL color (GREYSCALE)</li> </ul> <p></p>"},{"location":"portfolio/projects/doorbell/#digital-images","title":"Digital Images","text":"<p>A Bitmap is a digital image file that stores color data for pixels in a rectangular grid. Each pixel\u2019s color is defined by Red, Green, and Blue color intensity values. Images are displayed by emitting a corresponding blend of light for each dot on the screen. Effects like color filters are applied by altering RGB values for every pixel in the image.</p> <p></p> <p></p>"},{"location":"portfolio/projects/keyboard/","title":"IEEE Club Keyboard Project","text":"<p>The 2024-2025 IEEE BYU chapter project consisted of creating custom keyboards.  Hardware and software were based on a personal project previously completed by Carter Pollan (IEEE BYU chapter then-vice president).</p> <p>I began this project at the beginning of my sophomore year of college, and I quickly learned that it was far beyond the reach of my current skill level. Thanks to the help of Carter and other IEEE members, I was able to complete it by the end of the year.</p>"},{"location":"portfolio/projects/keyboard/#hardware","title":"Hardware","text":"<p>This project was my first introduction to PCBs and surface mount soldering. </p> <p>The PCB was completed as a group project with three other sophomore-level students. Using a provided template, we learned how to add the nets and traces required to implement a diode matrix and connect to our SEEED XIAO-SENSE microcontroller.</p> <p>Once the PCBs were delivered, we spent a long time soldering the diodes and hotswap sockets in place. The microcontroller also provided a challenge. To make it replaceable, we soldered a makeshift socket to the board and wire to the actual pins. I was not very good at soldering this, so I also learned quite a few desoldering techniques.</p> <p>After that, the assembly was fairly straightforward. After attaching the battery, 3D-printing a case, and screwing the PCB in place, attaching the keys was all that was left. I was quite happy with the outcome given my inexperience. </p>"},{"location":"portfolio/projects/keyboard/#software","title":"Software","text":"<p>With hardware complete, I moved to software and customization. Following Carter's example, I forked his repository of ZMK, an open source firmware for keyboards. Thanks to him, all that was required for a functioning keyboard was modifying the overlays to match our PCB. However, I chose to modify the keyboard layers to better meet my preferences.</p> <p>All files are available on my Github Repository.</p>"},{"location":"portfolio/projects/keyboard/#keyboard-layers","title":"Keyboard Layers","text":"<p>Standard Keyboard Layout </p> <p> Q W E R T Y U I O P A S D F G H J K L ; Z X C V B N M , . / </p> <p>To make up for the reduced number of keys, we employ homerow mods and two keys mapping to different layers.</p> <ul> <li>Homerow mods: holding select keys enables an alternate function. This provides easy access to modifiers like Shift and Control.</li> <li>Number: This key provides access to number keys and mathematical notation.</li> <li>Function: This key provides access to function keys and other common keyboard functions like Caps Lock and Arrow keys.</li> </ul> Homerow mods Number Function  <p> W E R T Y U I O P Z X C V B N M , . / </p> <p> 1 2 3 4 5 6 7 8 9 0 ` [ ] ' - = \\ / </p> <p> </p>"},{"location":"portfolio/projects/keyboard/#configuration","title":"Configuration","text":"<p>This custom key formation is programmed into a .keymap file. Modifications to the keymap can be made by reflashing the SEEED-XIAO microcontrollers.</p> .keymap selection <pre><code>-------------- *** --------------\n\n...\n\n/ {\n\n    behaviors {\n        bhm: balanced_homerow_mods {\n            compatible = \"zmk,behavior-hold-tap\";\n            #binding-cells = &lt;2&gt;;\n            tapping-term-ms = &lt;200&gt;;\n            quick-tap-ms = &lt;0&gt;;\n            require-prior-idle-ms = &lt;0&gt;;\n            flavor = \"balanced\";\n            bindings = &lt;&amp;kp&gt;, &lt;&amp;kp&gt;;\n        };\n        combos {\n            compatible = \"zmk,combos\";\n            combo_esc {\n                timeout-ms = &lt;50&gt;;\n                key-positions = &lt;0 10&gt;;\n                bindings = &lt;&amp;kp ESC&gt;;\n            };\n            combo_ble {\n                timeout-ms = &lt;50&gt;;\n                key-positions = &lt;30 35&gt;;\n                bindings = &lt;&amp;mo BLUETOOTH&gt;;\n            };\n        };\n    };\n\n    keymap0: keymap0 {\n        compatible = \"zmk,keymap\";\n\n        default_layer { // Layer 0\n            display-name = \"Base\";\n            bindings = &lt;\n        &amp;bhm ESC Q      &amp;kp W       &amp;kp E           &amp;kp R           &amp;kp T           &amp;kp Y           &amp;kp U       &amp;kp I           &amp;kp O       &amp;kp P\n        &amp;bhm LSHIFT A   &amp;bhm TAB S  &amp;bhm LCTRL D    &amp;bhm LALT F     &amp;bhm LCMD G     &amp;bhm RCMD H     &amp;bhm RALT J &amp;bhm RCTRL K    &amp;bhm TAB L  &amp;bhm RSHIFT SEMI\n        &amp;kp Z           &amp;kp X       &amp;kp C           &amp;kp V           &amp;kp B           &amp;kp N           &amp;kp M       &amp;kp COMMA       &amp;kp DOT     &amp;kp FSLH\n                                    &amp;mo NUMBER      &amp;mo FUNCTION    &amp;kp LCMD        &amp;kp RET         &amp;kp BSPC    &amp;kp SPACE\n            &gt;;\n        };\n\n        function {\n            display-name = \"Function\";\n            bindings = &lt;\n                    &amp;kp F1      &amp;kp F2      &amp;kp F3      &amp;kp F4      &amp;kp F5      &amp;kp F6      &amp;kp F7      &amp;kp F8      &amp;kp F9      &amp;kp F10\n                    &amp;kp LSHIFT  &amp;kp TAB     &amp;kp LCTRL   &amp;kp LALT    &amp;kp LCMD    &amp;kp LEFT    &amp;kp DOWN    &amp;kp UP      &amp;kp RIGHT   &amp;kp F11\n                    &amp;kp PSCRN   &amp;kp CAPS    &amp;none       &amp;none       &amp;none       &amp;kp PG_UP   &amp;kp PG_DN   &amp;kp HOME    &amp;kp END     &amp;kp F12\n                                            &amp;trans      &amp;trans      &amp;trans      &amp;trans      &amp;kp DEL     &amp;trans\n            &gt;;\n        };\n\n        number {\n            display-name = \"Number\";\n            bindings = &lt;\n                    &amp;kp N1      &amp;kp N2      &amp;kp N3      &amp;kp N4      &amp;kp N5          &amp;kp N6      &amp;kp N7      &amp;kp N8      &amp;kp N9      &amp;kp N0\n                    &amp;kp LSHIFT  &amp;kp TAB     &amp;kp LCTRL   &amp;kp LALT    &amp;kp LCMD        &amp;kp GRAVE   &amp;kp LBRC    &amp;kp RBRC    &amp;none       &amp;kp SQT\n                    &amp;none       &amp;none       &amp;none       &amp;none       &amp;none           &amp;none       &amp;kp MINUS   &amp;kp EQUAL   &amp;kp BSLH    &amp;kp FSLH\n                                            &amp;trans      &amp;trans      &amp;trans          &amp;kp LSHIFT  &amp;trans      &amp;trans\n            &gt;;\n        };\n\n        ...\n\n    };\n};\n\n-------------- *** --------------\n</code></pre> <p>While this unique setup takes time to get used to, I have found that it can help me speed up my programming by keeping my hands on the keyboard.</p> <p>I am currently working on an alternate keymap inspired by the Miryoku layout. </p>"},{"location":"portfolio/projects/light_following_robot/","title":"Light-following Robot","text":"<p>Arduino-based light-following robot. Made at BYU in ECEN 240 Circuits class. More info coming soon.</p>"},{"location":"portfolio/projects/rust_demos/","title":"Rust Demos","text":"<p>This Rust demonstration teaches the basic principles of Rust following the pattern of the Rust Book. In the future, I hope to create more demos teaching various principles or resources in Rust. Source code on Github.</p> <p>This demonstration is based on principles taught in the Rust Book. Links to relevant chapters are included with each section.</p>"},{"location":"portfolio/projects/rust_demos/#cargo","title":"Cargo","text":"<p>Chapter 1: Getting Started</p> <p>Install Rust using rustup.</p> <p>To create a new project with cargo, Rust's package manager, use the <code>new</code> command in the terminal:</p> <pre><code>$ cargo new [project_name]\n</code></pre> <p>Use the <code>build</code> command to compile your code.</p> <pre><code>$ cargo build\n</code></pre> <p>Use the <code>run</code> command to compile and then run the executable.</p> <pre><code>$ cargo run\n</code></pre>"},{"location":"portfolio/projects/rust_demos/#variables","title":"Variables","text":"<p>Chapter 3: Common Programming Concepts</p> <p><code>let</code> creates an immutable variable.</p> <p>'drone_id' is an immutable 32-bit integer (<code>i32</code>). Note that <code>u32</code> could be used to declare an unsigned 32-bit integer.</p> <pre><code>let drone_id: i32 = 1;\n</code></pre> <p>To change a variable, declare it as mutable with <code>mut</code>.</p> <p>'drone_status' is a mutable <code>String</code> (type is inferred).</p> <pre><code>let mut drone_status = \"Unarmed\";\ndrone_status = \"Armed\";\n</code></pre>"},{"location":"portfolio/projects/rust_demos/#functions","title":"Functions","text":"<p>Functions are declared with keyword <code>fn</code>. Every executable begins at the <code>main</code> function.</p> <p>A \"hello world\" program:</p> <pre><code>fn main() {\n    println!(\"Hello, world!\");\n}\n</code></pre> <p>Parameters and a return type may be included in the function signature. </p> <pre><code>fn function(param: i32) -&gt; f32 {}\n</code></pre> <p>Example 1: a 'log_message\" function with a parameter of type <code>String</code>.</p> <pre><code>fn log_message(message: String) {\n    println!(\"[LOG]: {}\", message)\n}\n</code></pre> <p>Example 2: An 'average' function with two parameters and a return type of <code>f32</code> (32-bit float).</p> <pre><code>fn average(x: f32, y:f32) -&gt; f32 {\n    (x + y) / 2.0\n}\n</code></pre> <p>Note that a <code>return</code> statement is not necessary. Any expression on the last line will act as a return value.</p>"},{"location":"portfolio/projects/rust_demos/#ownership","title":"Ownership","text":"<p>Chapter 4: Understanding Ownership</p> <p>Each value has a specific owner. Ownership can be passed from function to function to guarantee memory safety.</p> <p>Variable 'm1' is a String stored on the heap. When it is passed to 'log_message', ownership is passed to 'log_message'. Another call using 'm1' would result in a compiler error.</p> <pre><code>let m1 = String::from(\"Armed!\");\n    log_message(m1);\n\n    // println!(\"{}\", m1);\n    // Would result in compiler error\n</code></pre>"},{"location":"portfolio/projects/rust_demos/#structs","title":"Structs","text":"<p>Chapter 5: Using Structs to Structure Related Data</p> <p>Structs allow for custom data types. Structs are defined with a name and <code>key: value</code> pairs where each 'key' is a name that point to a field of type 'value'.</p> <pre><code>struct UAV {\n    id: u32,\n    is_armed: bool,\n    altitude: f32\n}\n</code></pre> <p>Values are accessed using dot notation.</p> <pre><code>uav.id, uav.is_armed, uav.altitude\n</code></pre>"},{"location":"portfolio/projects/rust_demos/#references","title":"References","text":"<p>Chapter 4: Understanding Ownership</p> <p>References control how data is shared and accessed. Immutable references (<code>&amp;</code>) are passed to functions that only read data. Mutable references (<code>&amp;mut</code>) are passed to functions that also need to write data. The compiler ensures that mutable and immutable references cannot coexist.</p> <p>The function 'arm_vehicle' takes a mutable reference.</p> <pre><code>fn arm_vehicle(uav: &amp;mut UAV) {\n    uav.is_armed = true;\n}\n</code></pre>"},{"location":"portfolio/projects/rust_demos/#crates","title":"Crates","text":"<p>Chapter 7: Managing Growing Projects with Packages, Crates, and Modules</p> <p>The <code>cargo.toml</code> file keeps track of project dependencies and information.</p> <pre><code>[package]\nname = \"demo2\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\n</code></pre> <p>Use <code>cargo add [crate]</code> to add a crate to the project. Cargo will automatically add this crate to the project depencencies.</p> <p>For example, we'll add the <code>rand</code> crate.</p> <pre><code>$ cargo add rand\n</code></pre> <p>This will add the <code>rand</code> crate to our <code>cargo.toml</code> file.</p> <pre><code>[dependencies]\nrand = \"0.9.1\"\n</code></pre> <p>To add items from a crate to a project, add a line with the <code>use</code> keyword and crate structure to the file (<code>use [crate]::[item]</code>). We'll add <code>random_bool</code> (a function within the <code>rand</code> crate).</p> <pre><code>use rand::random_bool;\n</code></pre> <p>Individual functions can also be called using the crate structure inline. For example, the <code>random_range</code> function can be called with</p> <pre><code>rand::random_range(..)\n</code></pre> <p>Information about specific crates can be found at crates.io.</p>"},{"location":"portfolio/projects/rust_demos/#error-handling","title":"Error Handling","text":"<p>Chapter 9: Error Handling</p> <p>Rust does not support null values. <code>Option&lt;T&gt;</code>, a standard library enum, can represent a value that can be something or nothing. The compiler forces you to handle both cases in order to prevent bugs.</p> <pre><code>enum Option&lt;T&gt; {\n    None,\n    Some(T),\n}\n</code></pre> <p>Potential failure can be handled in a similar manner. The Rust compiler forces you to acknowledge the possibility of error in some cases. Recoverable errors are represented with the <code>Result&lt;T, E&gt;</code> type.</p> <pre><code>enum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n</code></pre> <p>Unrecoverable errors cause code to panic! They can be caused by code execution or explicity called with the <code>panic!</code> macro.</p>"},{"location":"portfolio/projects/rust_demos/#pattern-matching","title":"Pattern Matching","text":"<p>Chapter 6: Enums and Pattern Matching</p> <p><code>match</code> is a control flow construct used to execute code by comparing a value to a pattern. It can be used to handle values with <code>Option</code> or <code>Result</code>.</p> <pre><code>match my_result {\n    Ok(t) =&gt; // success code using 't'\n    Err(e) =&gt; // error code using 'e'\n}\n</code></pre> <p>Matches are exhaustive. They must cover all possibilities.</p> <p>For example, we can use a <code>match</code> statement to handle sensor input.</p> <pre><code>match read_sensor() {\n    Ok(altitute) =&gt; {\n        drone.altitude = altitute;\n        println!(\"Drone {} Altitude read as {}\", drone.id, altitute);\n    }\n    Err(e) =&gt; {\n        println!(\"Failed! Error: {}\", e);\n    }\n}\n</code></pre>"},{"location":"portfolio/projects/rust_demos/#generic-types-and-traits","title":"Generic Types and Traits","text":"<p>Chapter 10: Generic Types, Traits, and Lifetimes</p> <p>Rust uses generic types and traits to handle duplication of concepts. </p> <p>Generics are abstract stand-ins for specific types. For example, <code>Option&lt;T&gt;</code> contains a generic type <code>T</code>. Similarly, <code>Result&lt;T,E&gt;</code> contains two generic types <code>T</code> and <code>E</code>. The Rust compiler will fill in the abstracted types with specific types at compile time, meaning there is no lost runtime efficiency.</p> <p>Traits can be used to define shared behavior and functionality. For example, in the Rust standard library the <code>Debug</code> trait will indicate that an object has formatted output for a debugging context.</p> <pre><code>pub trait Debug {\n    // Required method\n    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;\n}\n</code></pre> <p>An implementation of the Debug trait can be achieved with the <code>#[derive(Debug)]</code> macro or a manual implementation.</p>"},{"location":"portfolio/projects/rust_demos/#resources","title":"Resources","text":"<p>All information in this demo is based on the Rust Book from chapters 1-10. Much more detail and further information can be found there. It is very helpful for understanding why the Rust language and compiler behave as they do.</p> <p>Other resources</p> <ul> <li> <p>Rust by Example teaches Rust's basic principles with runnable examples.</p> </li> <li> <p>Rustlings contains small activities to practice reading and writing Rust code.</p> </li> <li> <p>Official documentation and other resources for learning Cargo, the compiler, embedded Rust, and more are provided by the Rust Foundation at the Rust Learn page.</p> </li> <li> <p>To learn Rust at a deeper level, Google's Android team has created a free Rust course called Comprehensive Rust. This course was created for experienced software engineers typically with a background in C++ or Java. </p> </li> </ul>"},{"location":"portfolio/projects/rustflight/","title":"RustFlight","text":"<p>I am currently working in the BYU Multiple Agent Intelligent Coordination and Control (MAGICC) Lab as a research assistant. I started in this position in April 2025 as a part of the IMMERSE Program under Dr. James Usevitch.</p> <p></p> <p>As a research asisstant I have researched machine learning, safety, and control theory using tools in the Rust ecosystem. I am currently contributing to the RustFlight project, a Rust-based port of the ROSflight project firmware designed for safety and adaptability.</p>"},{"location":"portfolio/projects/website/","title":"My Website","text":"<p>Made with Material for MkDocs. In the future, I will put more information about the process of making this site here.</p>"}]}